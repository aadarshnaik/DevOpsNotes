Why we need Helm? Issue we face with kubenetes.

In a product microservice application that needs to be deployed to the Kubernetes
cluster. It uses mySql database. We need to comeup with all the YAML cnfig files that
we need to comeup with to deploy msSQL and our microservice application that uses mySQL.

We create several YAML files for each application like deployment file, service files, config maps etc.
All the files are static in Kubernetes.
Its hard to maintan consistancy. If we edit directly on the cluster we will get 
consistency issues. That is something helm will address.

By only using Kubernetes, if we update any YAML and redeploy, the old YAML file is lost unless
we maintan a backup. There is no versioning system. Helm provides revision history.

What is helm?
Its a packaging manager of Kubernetes. Helm works with charts. Charts are like packages.
These charts will have all the template file and configuration required to create Kubernetes resources.

helm install <name_of_release> <chart_repo_name>/<chart_name> -namespace=<namespace_name>
helm upgrade <name_of_release> <chart_repo_name>/<chart_name> -namespace=<namespace_name> --values <address_to_values.yaml> 
helm rollback <name_of_release> <version_num> -namespce=<namespace_name>
helm uninstall <name_of_release>

Benefits of Helm.
1. Helm simplies the K8s deployemnt process by abstracting all complexity.
2. Uses charts which have all the template files and default values which we can override if req
   Experts create the charts for us so we dont need indepth knowledge of container we are building.
3. Helm maintains revision history ans we can revert to any version we want.
4. Dynamic Configutaion -->All the YAML files are generated automatically as templates and it'll 
   have placehoders as parameters.
5. The order of deployments that we had to do in Kubernetes is not required in Helm.
6. Helm gives us lifecycle hooks. If there is any work which is not directly related 
   to K8s but it has to be done during installation or upgradation, helm allows us to write hooks 
   that can be hooked into lifecycle events like installation, upgrade, uninstallation etc.
   This could be writing data to database, backing up a database or K8s cluster is in a 
   required state before we do installation.
7. Security. Inbuilt securit in charts and we can use signatures etc..

Helm is  written in Google Go Programming Lang.

Once Installed
helm --help

Helm Commands
-------------------
helm repo list --> to list out all the repositories
helm repo add <repo_name> <chart_url-link>
helm search repo <software_name>
helm search repo mySQL --versions --> to get all versions of software
helm repo remove <repo_name> --> to remove repository.

Terminal 1 --> kubectl get pods 
Terminal 2 -->  minikube ssh
		$docker images
Terminal 1 --> helm install mydb bitnami/mysql
copy paste the logs in notepad
Terminal 1 --> kubectl get pods
	       from logs we can get the port number, password, we copy the 
	       decoded password and save it 
Terminal 3 --> To connect to DB we run commands in logs 
Terminal 1 --> After we run commands in 3rd terminal if we run kubectl get pods
	       we get 2 pods.
To connect to primary service of read/write we run the commands in logs again 
and it asks for password that we have saved.
Now we are in mysql cli.

If we check the minikube if we run docker images we can find the bitnami/mysql image.

To get the logs at any point of time we can execute:
helm status mydb(name_of_release)

To uninstall we run 
helm uninstall <name_of_release> -n <namespace>

To upgrade an release
-----------------------
helm repo updates --> if there are any updates
helm list 
helm status mydb
helm upgrade <name_of_release> <chart_repo_name>/<chart_name> --set auth.rootPassword=$ROOT_PASSWORD
helm upgrade <name_of_release> <chart_repo_name>/<chart_name> -namespace=<namespace_name> --values <address_to_values.yaml> 

How helm works in background
---------------------------------------------
helm upgrade <name_of_release> <chart_repo_name>/<chart_name> --set auth.rootPassword=$ROOT_PASSWORD
1. Load the chart and its dependencies
2. Parse the values.yaml
3. Generate the yaml
4. Parse the YAML to kube objects and validate 
5. Generate YAML and send to kube

helm upgrade <name_of_release> <chart_repo_name>/<chart_name> --values <address_to_values.yaml> --dry-run
This will load the chart, substitute the values we provide into that chart, Render the required
K8s templates, format those templates to YAML but it'll not submit the YAML to k8s cluster.
Dry run is used to debug the YAML files that is generated by helm.

helm template <name_of_release> <chart_repo_name>/<chart_name> --values <address_to_values.yaml>

helm get notes <name_of_release> ==> to get release notes
helm get values <name_of_release> ==> custom values we have added
helm get values <name_of_release> --all ==> to get all the values
helm get values <name_of_release> --revision 1 ==> values in a particular revision
helm get manifest <name_of_release> --revison 1 ==> we can use the manifest to create k8s clusters

helm history mydb --> to get the history, revisions and error info.

To rollback to old version
------------------------------
helm rollback <name_of_release> <version_num>

This creates namespace for the installation on the go:
	helm install <name_of_release> <chart_repo_name>/<chart_name> -namespace=<namespace_name> --create-namespace 

If the Release is not there it'll install and if its there it'll upgrade:
	helm upgrade --install <name_of_release> <chart_repo_name>/<chart_name>

We can ask helm to create Release names by itself
	helm install bitnami/apache --generate-name
This will create a randomly generated name. 
To have a little control over generating names 
	helm install bitnami/apache --generate-name --name-template "mywebserver-{{randAlpha 7 | lower}}"
ranAlpha is a function to generate random characters.

helm install <name_of_release> <chart_repo_name>/<chart_name> --wait --timeout 7m
--wait will wait for the services and deployments to be created and pod should be up and running, 
  only then installation is considered successful.
--timeout 5m10s to set the wait time. default wait time is 5minutes.

--atomic ==> If the installation fails because of timeout we'd like to go back to previous successful deployment
helm install <name_of_release> <chart_repo_name>/<chart_name> --atomic --wait 

helm upgrade flags
---------------------------
	helm upgrade <name_of_release> <chart_repo_name>/<chart_name> --force
When we do normal upgrade k8s will restart the pods whose values have changed. If there is 
requirement where we have to start the pod we use --force. 
Internally helm will delete the current deployment and re-create the deployment.
	helm upgrade <name_of_release> <chart_repo_name>/<chart_name> --force

helm upgrade mywebserver bitnami/apache --cleanup-on-failure
CUSTOM CHARTS
--------------------

To create a chart:
	helm create firstchart
To release our chart:
	helm install firstapp firstchart/
To package a chart:
	helm package firstchart
To package a chart and pull latest dependeicies from other charts:
	helm package firstchart --dependencies-update/helm package firstchart -u
To give the destination of package:
	helm package firstchart -d c:/.....
To check out the manifest for the YAML file.
	helm template firstchart


HELM TEMPLATES
-------------------
{{"Helm Templating is" -}}, {{- "Cool"}}
We use dash(hyphen) to remove all unnecessary trailing spaces 

In values.yaml if we add
my:
  custom:
    data: "test"
We can access it in templating by 
{{.Values.my.custom.data}}
{{.Chart.Name}}
{{.Chart.Version}}
{{.Chart.AppVersion}}
{{.Chart.Annotations}}
.Chart can be used to access chart.yaml

{{.Release.Name}}
{{.Release.Namespace}}
{{.Release.IsInstall}}
{{.Release.IsUpgrade}}
{{.Release.Service}}

{{.Template.Name}}
{{.Template.BasePath}}

{{.Values.my.custom.data | default "testdefault" | upper | quote}}

{{- include "firstchart.labels" . | nindent 4 }}
nindent is used to give spaces as yaml is very particular about spaces


Helm gives us various template functions that can be used to transform data
within out templates eg., default, upper, quote etc..

IF AND IF-ELSE
-----------------
In values.yaml
my:
  flag: true
In deployment.yaml
{{- if .Values.my.flag}}
{{"Output of if" | nindent 2}}
{{- end}}

{{- if .Values.my.flag}}
{{"Output of if" | nindent 2}}
{{-else}}
{{"Output of else" | nindent 2}}
{{- end}}

WITH
-------
In values.yaml
my:
  flag: false
  values:
    - usa
    - india
    - mexico
    - brazil
    - uk
In Deployment yaml
{{- with .Values.my.values}}
{{- toYaml . | nindent 2}}
{{- end}}

{{- with .Values.my.values}}
{{- toYaml . | nindent 2}}
{{- else}}
{{"Else is executed if with values is empty"}}
{{- end}}

VARIABLES
------------
In deployment.yml
{{ $myFLAG := "test"}}

If we try to assign some values to same variable later, It'll be ignored
Initial value will be used

LOOPS
--------
In values.yaml
my:
  flag: false
  values:
    - usa
    - india
    - mexico
    - brazil
    - uk
In deployment.yaml
{{- range .Values.my.values}}
  - {{. | upper | quote}}
{{- end}}

We can use range to loop through a dictionary of values as well

{{- range $key,$value := .Values.image}}
  - {{$key}}: {{$value | quote}}
{{- end}}

CUSTOM TEMPLATE
--------------------
In _helpers.tpl file we can define our own template
In go templating language, templates are like functions 

{{/*
My Custom Template
*/}}
{{- define "firstchart.mytemplate" -}}
{{- .Values.myValue}}
{{- end}}

In values.yaml
myValue: test

In deployment.yaml
{{template "firstchart.mytemplate" .}}


When we define a chart dependency, a tgz is downloaded in charts folder
When we do installation or upgrade that chart will also be installed into our kubernetes cluster
To add a dependency in Chart.yaml
dependencies:
  - name: mysql
    version: "8.8.6"
    repository: "http://charts.bitnami.com/bitnami"

To conditionally enable or disable installation of a chart 
In values.yaml
mysql:
  enabled: false
In chart.yaml
  - name: mysql
    version: "8.8.6"
    repository: "http://charts.bitnami.com/bitnami"
    condition: mysql.enabled
